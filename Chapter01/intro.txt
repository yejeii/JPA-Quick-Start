1. JPA
    1.1 발전 흐름
        - JDBC( Java DataBase Connectivity )
          Java code + sql 이 혼재. => 유지보수 및 확장성 문제
         
          ex. com.rubypaper.persistence.jdbcEmployeeDAO
         
        - SQL Mapper
          Java code 와 sql 을 완전 분리.
          sql 서비스별 관리가 가능. => 응집도 높아지니까, 재사용성이 높아짐. 
          					  SQL 코드 품질 향상,  SQL 성능이 높아짐.
                   대표적으로 MyBatis 를 사용. 
                   
          MyBatis SQL 관리 파일
            - 서비스를 위한 sql( 응집도 향상 목적 )
              ex. p.50, s_emp-mapping.xml
              
            - 데이터베이스 접속과 관련한 설정 정보
              ex. sql-map-config.xml
        
          MyBatis 참고 사이트 - 한글 매뉴얼
          https://mybatis.org/mybatis-3/ko/index.html
        
        - ORM( 객체관계매퍼 )
          SQL Mapper 로 SQL을 분리를 해서 관리할 수 있지만,
                   그래도, SQL을 사용하면서 관리해야 하는 불편함.
          ( 순수 객체지향으로 DB 관련까지 개발하면 좋겠다...
          	=> SQL 이 없어도 가능하지 않을까? )
           
          JPA -> 하이버네이트 -> Spring JPA

                                  MySQL, Oracle 등
          java <-> 하이버네이트 <-> H2 데이터베이스
           VO        SQL 생성
    
    1.2 ORM 의 장점과 단점
        1.2.1 장점
            - SQL 을 직접 작성하지 않고, 사용하는 개발 언어로 DB에 접근
            - 객체지향적으로 코드를 작성할 수 있으므로 비즈니스 로직에 집중할 수 있음
            - DB 시스템이 추상화되어 있으므로 H2와 다른 DB 로 변경되더라도 추가로 필요한 작업이 거의 들지 않음
              -> DB 에 대한 종속성이 줄어듦
            - 매핑 정보가 정확하므로 ERD 에 대한 의존도를 낮출 수 있고, 유지보수에 유리
        
        1.2.2 단점
            - 프로젝트의 복잡성이 커질수록 사용 난이도가 올라감
            - 복잡하고 무거운 쿼리는 ORM 으로 해결이 불가능할 수도 있음
            - SQL 에 대한 직접적인 튜닝이 어려움
        
        1.2.3 중요한 개념
            - 엔티티
              DB 테이블과 매핑되는 객체(자바 클래스)
              @Entity 사용
            
            - 엔티티 매니저(Entity Manager, EM)
              엔티티의 생명주기와 밀접한 관련성
              프로젝트의 복잡성이 있는 경우 더욱 중요해짐

              엔티티를 관리해 DB와 애플리케이션 사이에서 객체를 관리(DML)하는 역할을 수행

              엔티티 매니저는 앤티티 매니저 팩토리(스레드 기반으로 동작)에서 생성됨
              -> 요청별로 엔티티 매니저가 생성됨을 의미
            
            - 영속성 컨텍스트
              엔티티 매니저는 엔티티를 영속성 컨텍스트에서 저장해서 관리함
              따라서, 영속성 컨텍스트는 엔티티를 관리하는 가상의 공간임

              영속성 컨텍스트에는 1차 캐시, 쓰기 지연, 변경 감지, 지연로딩의 특징이 있음

              - 1차 캐시
                엔티티를 조회하는 경우, 
                1차 캐시에서 해당되는 엔티티가 있는지 우선 조회한 후, 있으면 리턴, 
                없으면 DB 에 가서 찾아 1차 캐시에 저장한 후 반환함

                따라서, 캐시된 데이터를 조회할 때 DB를 거치지 않으므로 매우 빠르게 데이터 조회가 가능

                -> DML 작업은 1차 캐시를 통해 작업이 진행됨.
                -> 메모리 캐시를 통한 접근으로 디스크 I/O 를 줄이기 위한 노력
                   (데이터 처리 속도를 높이기 위한 처리)
                -> DB 의 데이터 버퍼와 유사한 역할을 수행
            
              - 쓰기 지연
                트랜잭션을 커밋하기 전까지는 DB 에 실제로 반영하지 않고 버퍼 캐시에 더티 블럭 상태로 
                있다가, 트랜잭션이 종료되면 모아두었던 쿼리문(더티 블럭)을 한번에 실행하는 것을 의미

                -> 적당한 묶음으로 쿼리를 요청할 수 있기 때문에 DB 부하를 줄일 수 있음

              - 변경 감지
                트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을
                비교한 후, 변경된 값이 있다면 변경 사항을 감지해 변경된 값을 DB 에 자동으로 반영함

                따라서, 쓰기 지연처럼 적당한 묶음으로 쿼리를 요청할 수 있고, DB 에 대한 부하를 낮출 수 있게 됨

              - 지연 로딩( 테이블간의 관계성이 있는 경우 )
                Lazy Loading 은 쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하지 않고,
                필요할 때 쿼리를 보내 데이터를 조회하는 것을 의미

                반대의 경우는 즉시 로딩
                조회할 때 쿼리를 보내 연관된 모든 엔티티의 데이터를 가져오는 것을 의미

                즉, 필요할 때 데이터 접근을 하겠다는 것

              - 공통점
                모든 DB 의 접근을 최소화하여 디스크 I/O 를 줄이기 위한 것
                성능 향상의 목적
                캐시를 하거나, 자주 쓰지 않게 하거나, 변화를 자동 감지해서 미리 준비하거나 하는 등의 방법을 이용

              - 결론
                JPA 를 사용하려면 반드시 상기의 특징을 이해하고 필요한 부분에 적용해야 함

                자바 ORM 표준 JPA 프로그래밍 (김영한)       
                데이터베이스 설계 기본서 - 중급서
                데이터베이스의 성능
        
        1.2.4 엔티티 매니저 팩토리
            - 엔티티 매니저 팩토리는 엔티티 매니저를 만들어 주는 기능을 담당
            - 여러 스레드가 동시에 접근해도 안전하게 사용할 수 있도록 설계되어 있음
            - 엔티티 매니저 팩토리는 서로 다른 스레드간에 공유를 해도 되지만,
              엔티티 매니저는 여러 스레드가 동시에 접근하면 동시성 문제가 발생하게 되므로 스레드간에 절대 공유하면 안됨
        
        1.2.5 영속성 컨텍스트  
            - 엔티티를 영구 저장하는 환경
            - 엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에서 엔티티를 보관, 관리함
            - 엔티티 생명 주기
                - 분리상태
                - 관리(영속) 상태
                - 비영속 상태
                - 삭제된 상태

            - 회원 관리 엔티티 기준으로 상태 구분
                - New(비영속 상태)
                  Member member = new Member(1L, "홍길동");

                  -> member 는 영속성 컨텍스트 외부에 있는 상태
                
                - Managed(영속(관리 상태))
                  em.persist(member);   

                  -> 영속 컨텍스트의 1차 캐시에 저장된 상태
                     member 는 영속성 컨텍스트 내부에 있는 상태

                - Detach(분리, 준영속 상태) : 영속 상태에서 벗어난 상태
                  em.detach(member);

                  -> member 는 영속성 컨텍스트의 내부에서 분리된 상태

                - Remove(삭제 상태)
                  em.remove(member);    

                  -> member 는 영속성 컨텍스트 및 DB 에서 삭제된 상태

            - 영속성 컨텍스트의 메모리 특징
                - 영속성 컨텍스트와 식별자
                    영속성 컨텍스트는 엔티티를 식별자 값으로 구분함
                    따라서, 영속 상태는 식별자 값이 반드시 필요하게 됨
                    식별자 값이 없으면 예외 발생

                    영속성 컨텍스트의 1차 캐시는 Map(key-value) 형태로 생각할 수 있음

                    member 를 관리하는 경우의 영속 컨텍스트의 1차 캐시의 모양

                    @id     entity          snapshot
                    'mem1'  member1 entity  member1 entity 의 원본  <-> DB
                    'mem2'  member2 entity  member2 entity 의 원본  <-> DB

                    snapshot 항목은 entity 의 update 상태 유무를 판단하기 위한 것임
                    ( 변경 감지용 )

            - 조회
                1차 캐시에서 식별자 값으로 엔티티 검색.
                있으면 바로 반환, 
                없으면 엔티티 매니저가 DB 에서 조회해서 엔티티를 생성함
                생성한 엔티티를 1차 캐시에 저장한 후, 영속성 상태의 엔티티를 반환함

                영속 엔티티의 동일성

                Member a = em.find("mem1");
                Member b = em.find("mem1");

                System.out.println(a==b?"동일":"동일X");

                동일성 비교를 하면, 결과는 항상 true

                즉, 영속성 컨텍스트는 항상 동일성을 보장함

                getById() : 검색보다는 가져온다는 의미가 있음
                            해당되는 엔티티가 없으면 예외가 발생함   

                findById() : 검색하는 의미가 있음
                            영속성 컨텍스트의 1차 캐시에서 선 확인 후, 
                            없을 때야 비로소 실제 DB 에 접근해서 데이터 유무 확인함

                            만약 entity 가 없으면, null 이 발생함

            - 등록
                엔티티 매니저는 트랜잭션을 커밋하기 직전까지 DB 에 엔티티를 저장하지 않고,
                내부 쿼리 저장소인 지연 SQL 저장소에 insert SQL 문을 계속 쌓아서 저장함

                트랜잭션이 커밋할 때 쓰기 지연 SQL 저장소에 저장된 쿼리들을 한꺼번에 DB 에 일괄 전송함
                ( 쓰기 지연 )
            
            - 수정
                커밋하기 전까지의 모든 SQL 은 쓰기 지연 SQL 저장소에 저장된 상태

                트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 flush() 를 호출함
                엔티티와 snapshot 을 비교해 변경된 엔티티를 찾음

                변경된 엔티티가 있으면 UPDATE SQL 을 생성해 쓰기 지연 SQL 저장소에 저장함

                JPA 의 기본 전략은 엔티티의 모든 필드를 대상으로 UPDATE 함
                이유 : 1. 애플리케이션 로딩 시점에 update sql 을 미리 생성해 두고 재사용이 가능할 수 있음
                       2. DB 에 동일한 SQL 을 전송하면 DB 는 이전에 파싱된 SQL 문을 재사용할 수 있게 됨
                
            - 삭제
                바로 삭제되지 않고, 쓰기 지연 SQL 저장소에 SQL 이 저장된 후, 트랜잭션이 커밋하여 
                엔티티 매니저의 flush() 가 호출되면 실제 DB 에 DELETE SQL 을 전달하게 됨

            - flush()
                영속성 컨텍스트의 변경 내용을 DB 에 반영하는 기능

                변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교하여
                수정이 발생된 엔티티를 찾음.
                수정된 엔티티는 UPDATE SQL 문을 만들어 쓰기 지연 SQL 저장소에 저장함

                쓰기 지연 SQL 저장소의 쿼리가 DB 에 전송(DML 문)

                영속성 컨텍스트를 flush 하는 방법
                    1. 엔티티 매니저의 flush() 호출
                    2. 트랜잭션 커밋시 자동 flush() 호출
                    3. JPQL 쿼리 실행시 자동 flush() 호출
                    








    1.2 EmployeeVO 설정
        - @Entity
            - Hibernate 에서 관리되는 엔티티 클래스임을 명시
            - H2 테이블과 매핑되는 클래스
        - @Table(name="S_EMP")
            - EmployeeVO 는 S_EMP 테이블과 매핑됨을 명시
        - @Id
            - S_EMP 테이블의 PK 와 매핑되는 식별자 변수 명시
            - 식별자 변수 : PK 와 매핑되는 변수를 의미
        - @Column(name = "START_DATE") 
            - 멤버명과 S_EMP 테이블 칼럼명이 다른경우 매핑될 컬럼명을 명시

2. Hibernate 

    2.3 JPQL (Java Persistence Query Language)
        - 기준 SQL 과의 차이점
          SQL : 대상이 DB 데이블의 데이터
          JPQL : 영속 컨테이너에서 관리되고 있는 엔티티가 대상
        
        - 비슷한 점
          기존의 SQL 문법 구조와 비슷


* 참고 *
    - Connection Pool 설정 
      <dataSource type="POOLED">  
          <property name="driver" value="org.h2.Driver"/>
          <property name="url" value="jdbc:h2:tcp://localhost/~/test"/>
          <property name="username" value="sa"/>
          <property name="password" value=""/>
      </dataSource>
  
      미리 접속된 connection 을 생성하여 보관하고 있다가, 요청을 받으면 connection 하나를 반환함
      -> 바로 연결된 것으로 사용하면 됨
      -> 접속을 위한 전처리가 필요 X
  
      default connection 개수 : 10